// This file was generated by counterfeiter
package iptablesfakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/guardian/kawasaki/iptables"
)

type FakeIPTablesDriver struct {
	ChainExistsStub        func(table, chain string) bool
	chainExistsMutex       sync.RWMutex
	chainExistsArgsForCall []struct {
		table string
		chain string
	}
	chainExistsReturns struct {
		result1 bool
	}
	CreateChainStub        func(table, chain string) error
	createChainMutex       sync.RWMutex
	createChainArgsForCall []struct {
		table string
		chain string
	}
	createChainReturns struct {
		result1 error
	}
	DeleteChainStub        func(table, chain string) error
	deleteChainMutex       sync.RWMutex
	deleteChainArgsForCall []struct {
		table string
		chain string
	}
	deleteChainReturns struct {
		result1 error
	}
	FlushChainStub        func(table, chain string) error
	flushChainMutex       sync.RWMutex
	flushChainArgsForCall []struct {
		table string
		chain string
	}
	flushChainReturns struct {
		result1 error
	}
	ResetChainStub        func(table, chain string, rules []iptables.Rule) error
	resetChainMutex       sync.RWMutex
	resetChainArgsForCall []struct {
		table string
		chain string
		rules []iptables.Rule
	}
	resetChainReturns struct {
		result1 error
	}
	DeleteChainReferencesStub        func(table, targetChain, referencedChain string) error
	deleteChainReferencesMutex       sync.RWMutex
	deleteChainReferencesArgsForCall []struct {
		table           string
		targetChain     string
		referencedChain string
	}
	deleteChainReferencesReturns struct {
		result1 error
	}
	PrependRuleStub        func(table, chain string, rule iptables.Rule) error
	prependRuleMutex       sync.RWMutex
	prependRuleArgsForCall []struct {
		table string
		chain string
		rule  iptables.Rule
	}
	prependRuleReturns struct {
		result1 error
	}
	AppendRuleStub        func(table, chain string, rule iptables.Rule) error
	appendRuleMutex       sync.RWMutex
	appendRuleArgsForCall []struct {
		table string
		chain string
		rule  iptables.Rule
	}
	appendRuleReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIPTablesDriver) ChainExists(table string, chain string) bool {
	fake.chainExistsMutex.Lock()
	fake.chainExistsArgsForCall = append(fake.chainExistsArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("ChainExists", []interface{}{table, chain})
	fake.chainExistsMutex.Unlock()
	if fake.ChainExistsStub != nil {
		return fake.ChainExistsStub(table, chain)
	} else {
		return fake.chainExistsReturns.result1
	}
}

func (fake *FakeIPTablesDriver) ChainExistsCallCount() int {
	fake.chainExistsMutex.RLock()
	defer fake.chainExistsMutex.RUnlock()
	return len(fake.chainExistsArgsForCall)
}

func (fake *FakeIPTablesDriver) ChainExistsArgsForCall(i int) (string, string) {
	fake.chainExistsMutex.RLock()
	defer fake.chainExistsMutex.RUnlock()
	return fake.chainExistsArgsForCall[i].table, fake.chainExistsArgsForCall[i].chain
}

func (fake *FakeIPTablesDriver) ChainExistsReturns(result1 bool) {
	fake.ChainExistsStub = nil
	fake.chainExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIPTablesDriver) CreateChain(table string, chain string) error {
	fake.createChainMutex.Lock()
	fake.createChainArgsForCall = append(fake.createChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("CreateChain", []interface{}{table, chain})
	fake.createChainMutex.Unlock()
	if fake.CreateChainStub != nil {
		return fake.CreateChainStub(table, chain)
	} else {
		return fake.createChainReturns.result1
	}
}

func (fake *FakeIPTablesDriver) CreateChainCallCount() int {
	fake.createChainMutex.RLock()
	defer fake.createChainMutex.RUnlock()
	return len(fake.createChainArgsForCall)
}

func (fake *FakeIPTablesDriver) CreateChainArgsForCall(i int) (string, string) {
	fake.createChainMutex.RLock()
	defer fake.createChainMutex.RUnlock()
	return fake.createChainArgsForCall[i].table, fake.createChainArgsForCall[i].chain
}

func (fake *FakeIPTablesDriver) CreateChainReturns(result1 error) {
	fake.CreateChainStub = nil
	fake.createChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPTablesDriver) DeleteChain(table string, chain string) error {
	fake.deleteChainMutex.Lock()
	fake.deleteChainArgsForCall = append(fake.deleteChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("DeleteChain", []interface{}{table, chain})
	fake.deleteChainMutex.Unlock()
	if fake.DeleteChainStub != nil {
		return fake.DeleteChainStub(table, chain)
	} else {
		return fake.deleteChainReturns.result1
	}
}

func (fake *FakeIPTablesDriver) DeleteChainCallCount() int {
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	return len(fake.deleteChainArgsForCall)
}

func (fake *FakeIPTablesDriver) DeleteChainArgsForCall(i int) (string, string) {
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	return fake.deleteChainArgsForCall[i].table, fake.deleteChainArgsForCall[i].chain
}

func (fake *FakeIPTablesDriver) DeleteChainReturns(result1 error) {
	fake.DeleteChainStub = nil
	fake.deleteChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPTablesDriver) FlushChain(table string, chain string) error {
	fake.flushChainMutex.Lock()
	fake.flushChainArgsForCall = append(fake.flushChainArgsForCall, struct {
		table string
		chain string
	}{table, chain})
	fake.recordInvocation("FlushChain", []interface{}{table, chain})
	fake.flushChainMutex.Unlock()
	if fake.FlushChainStub != nil {
		return fake.FlushChainStub(table, chain)
	} else {
		return fake.flushChainReturns.result1
	}
}

func (fake *FakeIPTablesDriver) FlushChainCallCount() int {
	fake.flushChainMutex.RLock()
	defer fake.flushChainMutex.RUnlock()
	return len(fake.flushChainArgsForCall)
}

func (fake *FakeIPTablesDriver) FlushChainArgsForCall(i int) (string, string) {
	fake.flushChainMutex.RLock()
	defer fake.flushChainMutex.RUnlock()
	return fake.flushChainArgsForCall[i].table, fake.flushChainArgsForCall[i].chain
}

func (fake *FakeIPTablesDriver) FlushChainReturns(result1 error) {
	fake.FlushChainStub = nil
	fake.flushChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPTablesDriver) ResetChain(table string, chain string, rules []iptables.Rule) error {
	var rulesCopy []iptables.Rule
	if rules != nil {
		rulesCopy = make([]iptables.Rule, len(rules))
		copy(rulesCopy, rules)
	}
	fake.resetChainMutex.Lock()
	fake.resetChainArgsForCall = append(fake.resetChainArgsForCall, struct {
		table string
		chain string
		rules []iptables.Rule
	}{table, chain, rulesCopy})
	fake.recordInvocation("ResetChain", []interface{}{table, chain, rulesCopy})
	fake.resetChainMutex.Unlock()
	if fake.ResetChainStub != nil {
		return fake.ResetChainStub(table, chain, rules)
	} else {
		return fake.resetChainReturns.result1
	}
}

func (fake *FakeIPTablesDriver) ResetChainCallCount() int {
	fake.resetChainMutex.RLock()
	defer fake.resetChainMutex.RUnlock()
	return len(fake.resetChainArgsForCall)
}

func (fake *FakeIPTablesDriver) ResetChainArgsForCall(i int) (string, string, []iptables.Rule) {
	fake.resetChainMutex.RLock()
	defer fake.resetChainMutex.RUnlock()
	return fake.resetChainArgsForCall[i].table, fake.resetChainArgsForCall[i].chain, fake.resetChainArgsForCall[i].rules
}

func (fake *FakeIPTablesDriver) ResetChainReturns(result1 error) {
	fake.ResetChainStub = nil
	fake.resetChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPTablesDriver) DeleteChainReferences(table string, targetChain string, referencedChain string) error {
	fake.deleteChainReferencesMutex.Lock()
	fake.deleteChainReferencesArgsForCall = append(fake.deleteChainReferencesArgsForCall, struct {
		table           string
		targetChain     string
		referencedChain string
	}{table, targetChain, referencedChain})
	fake.recordInvocation("DeleteChainReferences", []interface{}{table, targetChain, referencedChain})
	fake.deleteChainReferencesMutex.Unlock()
	if fake.DeleteChainReferencesStub != nil {
		return fake.DeleteChainReferencesStub(table, targetChain, referencedChain)
	} else {
		return fake.deleteChainReferencesReturns.result1
	}
}

func (fake *FakeIPTablesDriver) DeleteChainReferencesCallCount() int {
	fake.deleteChainReferencesMutex.RLock()
	defer fake.deleteChainReferencesMutex.RUnlock()
	return len(fake.deleteChainReferencesArgsForCall)
}

func (fake *FakeIPTablesDriver) DeleteChainReferencesArgsForCall(i int) (string, string, string) {
	fake.deleteChainReferencesMutex.RLock()
	defer fake.deleteChainReferencesMutex.RUnlock()
	return fake.deleteChainReferencesArgsForCall[i].table, fake.deleteChainReferencesArgsForCall[i].targetChain, fake.deleteChainReferencesArgsForCall[i].referencedChain
}

func (fake *FakeIPTablesDriver) DeleteChainReferencesReturns(result1 error) {
	fake.DeleteChainReferencesStub = nil
	fake.deleteChainReferencesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPTablesDriver) PrependRule(table string, chain string, rule iptables.Rule) error {
	fake.prependRuleMutex.Lock()
	fake.prependRuleArgsForCall = append(fake.prependRuleArgsForCall, struct {
		table string
		chain string
		rule  iptables.Rule
	}{table, chain, rule})
	fake.recordInvocation("PrependRule", []interface{}{table, chain, rule})
	fake.prependRuleMutex.Unlock()
	if fake.PrependRuleStub != nil {
		return fake.PrependRuleStub(table, chain, rule)
	} else {
		return fake.prependRuleReturns.result1
	}
}

func (fake *FakeIPTablesDriver) PrependRuleCallCount() int {
	fake.prependRuleMutex.RLock()
	defer fake.prependRuleMutex.RUnlock()
	return len(fake.prependRuleArgsForCall)
}

func (fake *FakeIPTablesDriver) PrependRuleArgsForCall(i int) (string, string, iptables.Rule) {
	fake.prependRuleMutex.RLock()
	defer fake.prependRuleMutex.RUnlock()
	return fake.prependRuleArgsForCall[i].table, fake.prependRuleArgsForCall[i].chain, fake.prependRuleArgsForCall[i].rule
}

func (fake *FakeIPTablesDriver) PrependRuleReturns(result1 error) {
	fake.PrependRuleStub = nil
	fake.prependRuleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPTablesDriver) AppendRule(table string, chain string, rule iptables.Rule) error {
	fake.appendRuleMutex.Lock()
	fake.appendRuleArgsForCall = append(fake.appendRuleArgsForCall, struct {
		table string
		chain string
		rule  iptables.Rule
	}{table, chain, rule})
	fake.recordInvocation("AppendRule", []interface{}{table, chain, rule})
	fake.appendRuleMutex.Unlock()
	if fake.AppendRuleStub != nil {
		return fake.AppendRuleStub(table, chain, rule)
	} else {
		return fake.appendRuleReturns.result1
	}
}

func (fake *FakeIPTablesDriver) AppendRuleCallCount() int {
	fake.appendRuleMutex.RLock()
	defer fake.appendRuleMutex.RUnlock()
	return len(fake.appendRuleArgsForCall)
}

func (fake *FakeIPTablesDriver) AppendRuleArgsForCall(i int) (string, string, iptables.Rule) {
	fake.appendRuleMutex.RLock()
	defer fake.appendRuleMutex.RUnlock()
	return fake.appendRuleArgsForCall[i].table, fake.appendRuleArgsForCall[i].chain, fake.appendRuleArgsForCall[i].rule
}

func (fake *FakeIPTablesDriver) AppendRuleReturns(result1 error) {
	fake.AppendRuleStub = nil
	fake.appendRuleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIPTablesDriver) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.chainExistsMutex.RLock()
	defer fake.chainExistsMutex.RUnlock()
	fake.createChainMutex.RLock()
	defer fake.createChainMutex.RUnlock()
	fake.deleteChainMutex.RLock()
	defer fake.deleteChainMutex.RUnlock()
	fake.flushChainMutex.RLock()
	defer fake.flushChainMutex.RUnlock()
	fake.resetChainMutex.RLock()
	defer fake.resetChainMutex.RUnlock()
	fake.deleteChainReferencesMutex.RLock()
	defer fake.deleteChainReferencesMutex.RUnlock()
	fake.prependRuleMutex.RLock()
	defer fake.prependRuleMutex.RUnlock()
	fake.appendRuleMutex.RLock()
	defer fake.appendRuleMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeIPTablesDriver) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ iptables.IPTablesDriver = new(FakeIPTablesDriver)
